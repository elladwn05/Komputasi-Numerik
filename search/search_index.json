{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Biodata Nama : Ella Dwi Novitasari NIM : 180411100126 Kelas : Komputasi Numerik 4B Dosen Pengampu : Mula'ab,S.SI.,M.kom Jurusan : Teknik Informatika","title":"Biodata"},{"location":"#biodata","text":"Nama : Ella Dwi Novitasari NIM : 180411100126 Kelas : Komputasi Numerik 4B Dosen Pengampu : Mula'ab,S.SI.,M.kom Jurusan : Teknik Informatika","title":"Biodata"},{"location":"Tugas 1_Numerical Solution of Algebraic and Transcendental Equation/","text":"Numerical Solution of Algebraic and Transcendental Equation 1. Mencari akar dengan cara Bisection \u200b Metode bisection adalah algoritma pencarian akar pada sebuah interval. Interval tersebut membagi dua bagian lalu memilih bagian mana yang mengandung akar dan bagian yang tidak mengandung akar dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh akar persamaan atau mendekati akar persamaan. Metode ini berlaku ketika ingin memecahkan persamaan dengan merupakan fungsi kontinyu. def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) output 1.9999999985098835 2. Mencari akar dengan cara Newton-Rapshon \u200b Metode Newton-Raphson adalah metode pencarian akar suatu fungsi dengan pendekatan satu titik, dimana fungsi mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi Dua(Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal, semakin dekat titik awal yang kita pilih dengan akar sebenarnya maka semakin cepat konvergen ke akarnya. def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) output Found solution after 4 iterations. 1.9999847409781035 3. Mencari akar dengan cara Secant \u200b Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi harus memiliki turunan ., sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu, muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik dan . def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) output 2.0000003178913373 4. Mencari akar dengan cara Regulasi Falsi \u200b Metode Regular Falsi adalah panduan konsep Metode Bagi Dua dan Metode Secant dimana menggunakan konsep Metode Bagi Dua karena dimulai dengan pemilihan dua titik awal dan sedemikian sehingga dan berlawanan tanda atau . Kemudian menggunakan konsep Metode Secant yaitu dengan menarik garis dari titik dan sedemikian sehingga garis berpotongan pada sumbu \u2013 dan memotong kurva atau grafik fungsi pada titik dan . Sehingga Metode Regular Falsi ini akan menghasilkan titik potong pada sumbu- yaitu yang merupakan calon akar dan tetap berada dalam interval . Metode ini kemudian berlanjut dengan menghasilkan berturut-turut interval yang semuanya berisi akar . error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) output x = 2.000000000174259","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"Tugas 1_Numerical Solution of Algebraic and Transcendental Equation/#numerical-solution-of-algebraic-and-transcendental-equation","text":"1. Mencari akar dengan cara Bisection \u200b Metode bisection adalah algoritma pencarian akar pada sebuah interval. Interval tersebut membagi dua bagian lalu memilih bagian mana yang mengandung akar dan bagian yang tidak mengandung akar dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh akar persamaan atau mendekati akar persamaan. Metode ini berlaku ketika ingin memecahkan persamaan dengan merupakan fungsi kontinyu. def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) output 1.9999999985098835 2. Mencari akar dengan cara Newton-Rapshon \u200b Metode Newton-Raphson adalah metode pencarian akar suatu fungsi dengan pendekatan satu titik, dimana fungsi mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi Dua(Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal, semakin dekat titik awal yang kita pilih dengan akar sebenarnya maka semakin cepat konvergen ke akarnya. def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) output Found solution after 4 iterations. 1.9999847409781035 3. Mencari akar dengan cara Secant \u200b Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi harus memiliki turunan ., sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu, muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik dan . def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) output 2.0000003178913373 4. Mencari akar dengan cara Regulasi Falsi \u200b Metode Regular Falsi adalah panduan konsep Metode Bagi Dua dan Metode Secant dimana menggunakan konsep Metode Bagi Dua karena dimulai dengan pemilihan dua titik awal dan sedemikian sehingga dan berlawanan tanda atau . Kemudian menggunakan konsep Metode Secant yaitu dengan menarik garis dari titik dan sedemikian sehingga garis berpotongan pada sumbu \u2013 dan memotong kurva atau grafik fungsi pada titik dan . Sehingga Metode Regular Falsi ini akan menghasilkan titik potong pada sumbu- yaitu yang merupakan calon akar dan tetap berada dalam interval . Metode ini kemudian berlanjut dengan menghasilkan berturut-turut interval yang semuanya berisi akar . error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) output x = 2.000000000174259","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"Tugas 2_Error in Numerical Computations/","text":"Error in Numerical Computations Pengertian \u200b Error atau galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numerik dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar, sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. \u200b Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati yaitu suatu metode yang memberikan solusi yang sesungguhnya karena memiliki galat ( error ) yang bernilai nol, tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas tidak selalu bisa diterapkan, maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati. Nilai galat (nilai kesalahan) \u200b Besarnya kesalahan atas suatu nilai taksiran dapat dinyatakan secara kuantitatif dan kualitatif. Besarnya kesalahan yang dinyatakan secara kuantitatif disebut Kesalahan Absolut. Besarnya kesalahan yang dinyatakan secara kualitatif disebut dengan Kesalahan Relatif. Absolute error \u200b Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Ini dilambangkan dengan : $$ Ea = |X - x| $$ Relative error \u200b Relative error biasa disebut sebagai kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Ini dilambangkan dengan : $$ Er = |Xt - Xa / Xt| $$ Penyebab terjadinya error \u200b Dibedakan menjadi 3, yaitu : Round-off-errors Truncation errors Inherent errors Penjelasan Round-off-errors \u200b Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil. Masalah timbul bila komputasi numerik dikerjakan oleh mesin (dalam hal ini komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer, keterbatasan komputer dalam menyajikan bilangan riil menghasilkan galat yang disebut galat pembulatan. Truncation errors \u200b Galat pemotongan adalah galat yang ditimbulkan oleh pembatasan jumlah komputasi yang digunakan pada proses metode numerik. Banyak metode dalam metode numerik yang penurunan rumusnya menggunakan proses iterasi yang jumlahnya tak terhingga, sehingga untuk membatasi proses penghitungan, jumlah iterasi dibatasi sampai langkah ke n. Hasil penghitungan sampai langkah ke n akan menjadi hasil hampiran dan nilai penghitungan langkah n keatas akan menjadi galat pemotongan. dalam hal ini galat pemotongan kan menjadi sangat kecil sekali jika nilai n di perbesar. Konsekuensinya tentu saja jumlah proses penghitungannya akan semakin banyak. Inherent errors \u200b Galat bawaan adalah galat dalam nilai data yang terjadi akibat kekeliruan dalam menyalin data, salah membaca skala atau kesalahan karena kurangnya pengertian mengenai hukum-hukum fisik dari data yang diukur. Kesalahan ini sering terjadi karena faktor human error. Maclaurin \u200b Suatu fungsi f(x) yang memiliki f'(x), f''(x), f'''(x) , dan seterusnya yang kontinyu dalam interval I dengan maka untuk x disekitar a yaitu , f(x) dapat diekspansi kedalam deret taylor \u200b Algoritma dari maclaurin dengan algoritma itu kita dapat menyederhanakan sebagai berikut : Listing program import math error = 0.001 def f(x): f_turunan = 1 current=i=0 iteration = True while iteration: old= current current += (f_turunan*(x**i))/math.factorial(i) print('f ke-', i,'=',current, 'Ea=', current-old ) if current-old < error: iteration = False else: f_turunan *=3 i +=1 f(4) output f ke- 0 = 1.0 Ea= 1.0 f ke- 1 = 13.0 Ea= 12.0 f ke- 2 = 85.0 Ea= 72.0 f ke- 3 = 373.0 Ea= 288.0 f ke- 4 = 1237.0 Ea= 864.0 f ke- 5 = 3310.6 Ea= 2073.6 f ke- 6 = 7457.799999999999 Ea= 4147.199999999999 f ke- 7 = 14567.285714285714 Ea= 7109.4857142857145 f ke- 8 = 25231.514285714286 Ea= 10664.228571428572 f ke- 9 = 39450.485714285714 Ea= 14218.971428571429 f ke- 10 = 56513.25142857143 Ea= 17062.765714285713 f ke- 11 = 75127.17766233766 Ea= 18613.926233766237 f ke- 12 = 93741.1038961039 Ea= 18613.926233766237 f ke- 13 = 110923.18965034965 Ea= 17182.085754245752 f ke- 14 = 125650.69172541745 Ea= 14727.502075067794 f ke- 15 = 137432.69338547168 Ea= 11782.00166005423 f ke- 16 = 146269.19463051236 Ea= 8836.50124504068 f ke- 17 = 152506.7249211293 Ea= 6237.530290616938 f ke- 18 = 156665.07844820726 Ea= 4158.3535270779685 f ke- 19 = 159291.4069916249 Ea= 2626.3285434176505 f ke- 20 = 160867.20411767552 Ea= 1575.797126050602 f ke- 21 = 161767.65961827585 Ea= 900.4555006003357 f ke- 22 = 162258.81716405787 Ea= 491.1575457820145 f ke- 23 = 162515.07327490064 Ea= 256.25611084277625 f ke- 24 = 162643.20133032204 Ea= 128.12805542140268 f ke- 25 = 162704.7027969243 Ea= 61.501466602261644 f ke- 26 = 162733.08808920227 Ea= 28.385292277962435 f ke- 27 = 162745.70377465914 Ea= 12.61568545686896 f ke- 28 = 162751.1104969978 Ea= 5.406722338666441 f ke- 29 = 162753.3477614138 Ea= 2.237264416005928 f ke- 30 = 162754.2426671802 Ea= 0.8949057663849089 f ke- 31 = 162754.58908231556 Ea= 0.34641513536917046 f ke- 32 = 162754.71898799133 Ea= 0.12990567577071488 f ke- 33 = 162754.7662264189 Ea= 0.04723842756357044 f ke- 34 = 162754.7828988051 Ea= 0.016672386205755174 f ke- 35 = 162754.7886150518 Ea= 0.005716246698284522 f ke- 36 = 162754.79052046736 Ea= 0.0019054155563935637 f ke- 37 = 162754.79113843996 Ea= 0.0006179726042319089","title":"Error in Numerical Computations"},{"location":"Tugas 2_Error in Numerical Computations/#error-in-numerical-computations","text":"Pengertian \u200b Error atau galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numerik dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar, sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. \u200b Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati yaitu suatu metode yang memberikan solusi yang sesungguhnya karena memiliki galat ( error ) yang bernilai nol, tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas tidak selalu bisa diterapkan, maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati. Nilai galat (nilai kesalahan) \u200b Besarnya kesalahan atas suatu nilai taksiran dapat dinyatakan secara kuantitatif dan kualitatif. Besarnya kesalahan yang dinyatakan secara kuantitatif disebut Kesalahan Absolut. Besarnya kesalahan yang dinyatakan secara kualitatif disebut dengan Kesalahan Relatif. Absolute error \u200b Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Ini dilambangkan dengan : $$ Ea = |X - x| $$ Relative error \u200b Relative error biasa disebut sebagai kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Ini dilambangkan dengan : $$ Er = |Xt - Xa / Xt| $$ Penyebab terjadinya error \u200b Dibedakan menjadi 3, yaitu : Round-off-errors Truncation errors Inherent errors Penjelasan Round-off-errors \u200b Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil. Masalah timbul bila komputasi numerik dikerjakan oleh mesin (dalam hal ini komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer, keterbatasan komputer dalam menyajikan bilangan riil menghasilkan galat yang disebut galat pembulatan. Truncation errors \u200b Galat pemotongan adalah galat yang ditimbulkan oleh pembatasan jumlah komputasi yang digunakan pada proses metode numerik. Banyak metode dalam metode numerik yang penurunan rumusnya menggunakan proses iterasi yang jumlahnya tak terhingga, sehingga untuk membatasi proses penghitungan, jumlah iterasi dibatasi sampai langkah ke n. Hasil penghitungan sampai langkah ke n akan menjadi hasil hampiran dan nilai penghitungan langkah n keatas akan menjadi galat pemotongan. dalam hal ini galat pemotongan kan menjadi sangat kecil sekali jika nilai n di perbesar. Konsekuensinya tentu saja jumlah proses penghitungannya akan semakin banyak. Inherent errors \u200b Galat bawaan adalah galat dalam nilai data yang terjadi akibat kekeliruan dalam menyalin data, salah membaca skala atau kesalahan karena kurangnya pengertian mengenai hukum-hukum fisik dari data yang diukur. Kesalahan ini sering terjadi karena faktor human error. Maclaurin \u200b Suatu fungsi f(x) yang memiliki f'(x), f''(x), f'''(x) , dan seterusnya yang kontinyu dalam interval I dengan maka untuk x disekitar a yaitu , f(x) dapat diekspansi kedalam deret taylor \u200b Algoritma dari maclaurin dengan algoritma itu kita dapat menyederhanakan sebagai berikut : Listing program import math error = 0.001 def f(x): f_turunan = 1 current=i=0 iteration = True while iteration: old= current current += (f_turunan*(x**i))/math.factorial(i) print('f ke-', i,'=',current, 'Ea=', current-old ) if current-old < error: iteration = False else: f_turunan *=3 i +=1 f(4) output f ke- 0 = 1.0 Ea= 1.0 f ke- 1 = 13.0 Ea= 12.0 f ke- 2 = 85.0 Ea= 72.0 f ke- 3 = 373.0 Ea= 288.0 f ke- 4 = 1237.0 Ea= 864.0 f ke- 5 = 3310.6 Ea= 2073.6 f ke- 6 = 7457.799999999999 Ea= 4147.199999999999 f ke- 7 = 14567.285714285714 Ea= 7109.4857142857145 f ke- 8 = 25231.514285714286 Ea= 10664.228571428572 f ke- 9 = 39450.485714285714 Ea= 14218.971428571429 f ke- 10 = 56513.25142857143 Ea= 17062.765714285713 f ke- 11 = 75127.17766233766 Ea= 18613.926233766237 f ke- 12 = 93741.1038961039 Ea= 18613.926233766237 f ke- 13 = 110923.18965034965 Ea= 17182.085754245752 f ke- 14 = 125650.69172541745 Ea= 14727.502075067794 f ke- 15 = 137432.69338547168 Ea= 11782.00166005423 f ke- 16 = 146269.19463051236 Ea= 8836.50124504068 f ke- 17 = 152506.7249211293 Ea= 6237.530290616938 f ke- 18 = 156665.07844820726 Ea= 4158.3535270779685 f ke- 19 = 159291.4069916249 Ea= 2626.3285434176505 f ke- 20 = 160867.20411767552 Ea= 1575.797126050602 f ke- 21 = 161767.65961827585 Ea= 900.4555006003357 f ke- 22 = 162258.81716405787 Ea= 491.1575457820145 f ke- 23 = 162515.07327490064 Ea= 256.25611084277625 f ke- 24 = 162643.20133032204 Ea= 128.12805542140268 f ke- 25 = 162704.7027969243 Ea= 61.501466602261644 f ke- 26 = 162733.08808920227 Ea= 28.385292277962435 f ke- 27 = 162745.70377465914 Ea= 12.61568545686896 f ke- 28 = 162751.1104969978 Ea= 5.406722338666441 f ke- 29 = 162753.3477614138 Ea= 2.237264416005928 f ke- 30 = 162754.2426671802 Ea= 0.8949057663849089 f ke- 31 = 162754.58908231556 Ea= 0.34641513536917046 f ke- 32 = 162754.71898799133 Ea= 0.12990567577071488 f ke- 33 = 162754.7662264189 Ea= 0.04723842756357044 f ke- 34 = 162754.7828988051 Ea= 0.016672386205755174 f ke- 35 = 162754.7886150518 Ea= 0.005716246698284522 f ke- 36 = 162754.79052046736 Ea= 0.0019054155563935637 f ke- 37 = 162754.79113843996 Ea= 0.0006179726042319089","title":"Error in Numerical Computations"},{"location":"Tugas 3_Eliminasi Gauss/","text":"Eliminasi Gauss Jordan \u200b Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks, caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah itu menjadi matriks baris dan lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss hanya saja augmented matrik pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan Listing Program import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 Panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| Pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u200b Metode Iterasi Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan persamaan linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel Listing Program def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3.","title":"Eliminasi Gauss Jordan"},{"location":"Tugas 3_Eliminasi Gauss/#eliminasi-gauss-jordan","text":"\u200b Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks, caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah itu menjadi matriks baris dan lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss hanya saja augmented matrik pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan Listing Program import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 Panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| Pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Eliminasi Gauss Jordan"},{"location":"Tugas 3_Eliminasi Gauss/#eliminasi-gauss-jacobi","text":"\u200b Metode Iterasi Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan persamaan linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Eliminasi Gauss Jacobi"},{"location":"Tugas 3_Eliminasi Gauss/#program-gauss-seidel","text":"Listing Program def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3.","title":"Program Gauss Seidel"},{"location":"Tugas 4_Romberg/","text":"Metode Integrasi Romberg \u200b Integrasi Romberg merupakan teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( Richardson's extrapolation ) yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga yang lebih akurat. \u200b Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( error tolerance ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode trapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi dan fungsi transeden. Pada proses Integrasi Romberg mula-mula kita hitung kuadratur dengan lebar langkah h dan 2h. Defisini kuadratur adalah \u200b Untuk menurunkan galat hampiran integral dari O(h2) menjadi O(h2n + 2) dapat digunakan ekstrapolasi Richardson seperti dinyatakan dalam teorema : \u200b Jika didefinisikan barisan kuadratur {I(i,j) : i >= j dimana j =1, 2, 3, ....} untuk hampiran integral f(x) pada [a, b] sebagai: \u200b I (i, 1) = Ti \u2013 1. i \u2265 1 ( barisan aturan trapezium majemuk) \u200b I (i, 2) = Si \u2013 1. i \u2265 2 (barisan aturan Simpson majemuk) \u200b I (i, 3) = Bi \u2013 1. i \u2265 3 (barisan aturan Boole majemuk) \u200b Maka integrasi romberg untuk meningkatkan keakuratan hampiran integral dapat di tulis sebagai Listing Program import numpy as np def trapezcomp(f, a, b, n): \"\"\" Composite trapezoidal function integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound n: number of panels to create between ``a`` and ``b`` \"\"\" # Initialization h = (b - a) / n x = a # Composite rule In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): \"\"\" Romberg integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound p: number of rows in the Romberg table \"\"\" I = np.zeros((p, p)) for k in range(0, p): # Composite trapezoidal rule for 2^k panels I[k, 0] = trapezcomp(f, a, b, 2**k) # Romberg recursive formula for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) print(I[k, 0:k+1]) # display intermediate results return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(solution) # 1.00000000814 output [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] 1.0000000081440203","title":"Metode Integrasi Romberg"},{"location":"Tugas 4_Romberg/#metode-integrasi-romberg","text":"\u200b Integrasi Romberg merupakan teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( Richardson's extrapolation ) yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga yang lebih akurat. \u200b Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( error tolerance ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode trapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi dan fungsi transeden. Pada proses Integrasi Romberg mula-mula kita hitung kuadratur dengan lebar langkah h dan 2h. Defisini kuadratur adalah \u200b Untuk menurunkan galat hampiran integral dari O(h2) menjadi O(h2n + 2) dapat digunakan ekstrapolasi Richardson seperti dinyatakan dalam teorema : \u200b Jika didefinisikan barisan kuadratur {I(i,j) : i >= j dimana j =1, 2, 3, ....} untuk hampiran integral f(x) pada [a, b] sebagai: \u200b I (i, 1) = Ti \u2013 1. i \u2265 1 ( barisan aturan trapezium majemuk) \u200b I (i, 2) = Si \u2013 1. i \u2265 2 (barisan aturan Simpson majemuk) \u200b I (i, 3) = Bi \u2013 1. i \u2265 3 (barisan aturan Boole majemuk) \u200b Maka integrasi romberg untuk meningkatkan keakuratan hampiran integral dapat di tulis sebagai Listing Program import numpy as np def trapezcomp(f, a, b, n): \"\"\" Composite trapezoidal function integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound n: number of panels to create between ``a`` and ``b`` \"\"\" # Initialization h = (b - a) / n x = a # Composite rule In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): \"\"\" Romberg integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound p: number of rows in the Romberg table \"\"\" I = np.zeros((p, p)) for k in range(0, p): # Composite trapezoidal rule for 2^k panels I[k, 0] = trapezcomp(f, a, b, 2**k) # Romberg recursive formula for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) print(I[k, 0:k+1]) # display intermediate results return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(solution) # 1.00000000814 output [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] 1.0000000081440203","title":"Metode Integrasi Romberg"},{"location":"Tugas 5_Turunan Numerik/","text":"Turunan Numerik \u200b Persoalan turunan numerik ialah menentukan hampiran nilai turunan fungsi f yang diberikan dalam bentuk tabel. Rumus Turunan Numerik : Bila persamaan fungsi f(x) diberikan secara eksplisit, maka kita dapat menentukan fungsi turunannya, f '(x), f \"(x), ..., f (n+1)(x), lalu menggunakannya untuk menghitung nilai turunan fungsi di x = t. Tetapi jika fungsi f(x) tidak diketahui secara eksplisit, tetapi kita hanya memiliki beberapa titik data saja. Pada kasus seperti ini kita tidak dapat menemukan nilai turunan fungsi secara analitik. Sebaliknya, pada kasus lain, meskipun f(x) diketahui secara eksplisit tetapi bentuknya rumit sehingga menentukan fungsi turunannya merupakan pekerjaan yang tidak mangkus. 3 Pendekatan Dalam Menghitung Turunan Numerik Hampiran Selisih-Maju (forward difference approximation) Hampiran Selisih-Mundur (backward difference approximation) Hampiran Selisih-Pusat (center difference approximation) Ekstrapolasi Richardson \u200b Ekstrapolasi Richardson juga dapat diterapkan pada turunan numerik untuk memperoleh solusi yang lebih teliti. Misalkan D(h) dan D(2h) adalah hampiran f'(x0) dengan mengambil titik-titik masing-masing sejarak h dan 2h. Misalkan untuk menghitung f '(x0) digunakan rumus hampiran beda- pusat orde O(h2) : \u200b Kurangi kedua persamaan maka menghasilkan : \u200b Ekstrapolasi Richardson dapat diperluas penggunaannya untuk mendapatkan nilai turunan fungsi yang lebih baik. Listing Program Buatlah program untuk penyelesaian estimasi pada f'(0,5) dari fungsi f(x) : \u20130.1x4 \u2013 0.15x3 \u2013 0.5x2 \u2013 0.25x + 1.2 mulai dengan h1 = 0,5 dan h2 = 0,25 dengan Ekstrapolasi Richardson. from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): '''Richardson extrapolation method for numerical calculation of first derivative ''' k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('>>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<<') print(\"=======================================================================\") print('f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5') print(\"=======================================================================\") print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print(\"=======================================================================\") print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) output f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 ======================================================================= -0.91250000000000530687 ======================================================================= diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050","title":"Turunan Numerik"},{"location":"Tugas 5_Turunan Numerik/#turunan-numerik","text":"\u200b Persoalan turunan numerik ialah menentukan hampiran nilai turunan fungsi f yang diberikan dalam bentuk tabel. Rumus Turunan Numerik : Bila persamaan fungsi f(x) diberikan secara eksplisit, maka kita dapat menentukan fungsi turunannya, f '(x), f \"(x), ..., f (n+1)(x), lalu menggunakannya untuk menghitung nilai turunan fungsi di x = t. Tetapi jika fungsi f(x) tidak diketahui secara eksplisit, tetapi kita hanya memiliki beberapa titik data saja. Pada kasus seperti ini kita tidak dapat menemukan nilai turunan fungsi secara analitik. Sebaliknya, pada kasus lain, meskipun f(x) diketahui secara eksplisit tetapi bentuknya rumit sehingga menentukan fungsi turunannya merupakan pekerjaan yang tidak mangkus. 3 Pendekatan Dalam Menghitung Turunan Numerik Hampiran Selisih-Maju (forward difference approximation) Hampiran Selisih-Mundur (backward difference approximation) Hampiran Selisih-Pusat (center difference approximation) Ekstrapolasi Richardson \u200b Ekstrapolasi Richardson juga dapat diterapkan pada turunan numerik untuk memperoleh solusi yang lebih teliti. Misalkan D(h) dan D(2h) adalah hampiran f'(x0) dengan mengambil titik-titik masing-masing sejarak h dan 2h. Misalkan untuk menghitung f '(x0) digunakan rumus hampiran beda- pusat orde O(h2) : \u200b Kurangi kedua persamaan maka menghasilkan : \u200b Ekstrapolasi Richardson dapat diperluas penggunaannya untuk mendapatkan nilai turunan fungsi yang lebih baik. Listing Program Buatlah program untuk penyelesaian estimasi pada f'(0,5) dari fungsi f(x) : \u20130.1x4 \u2013 0.15x3 \u2013 0.5x2 \u2013 0.25x + 1.2 mulai dengan h1 = 0,5 dan h2 = 0,25 dengan Ekstrapolasi Richardson. from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): '''Richardson extrapolation method for numerical calculation of first derivative ''' k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('>>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<<') print(\"=======================================================================\") print('f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5') print(\"=======================================================================\") print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print(\"=======================================================================\") print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) output f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 ======================================================================= -0.91250000000000530687 ======================================================================= diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050","title":"Turunan Numerik"},{"location":"Tugas 6_Persamaan Diferensial Biasa/","text":"Persamaan Diferensial Biasa \u200b Persamaan diferensial biasa adalah persamaan diferensial dimana fungsi yang tidak diketahui (variabel terikat) adalah fungsi dari variabel bebas tunggal. Dalam bentuk paling sederhana fungsi yang tidak diketahui ini adalah fungsi riil atau fungsi kompleks, tetapi secara umum bisa juga berupa fungsi vektor maupun matriks. Lebih jauh lagi, persamaan diferensial biasa digolongkan berdasarkan orde tertinggi dari turunan terhadap variabel terikat yang muncul dalam persamaan tersebut. Contoh sederhana adalah hukum gerak kedua Newton yang menghasilkan persamaan diferensial \u200b untuk gerakan partikel dengan massa konstan m . Pada umumnya, gaya F tergantung kepada posisi partikel x(t) pada waktu t dan demikian fungsi yang tidak diketahui x(t) muncul pada kedua ruas persamaan diferensial seperti yang diindikasikan dalam notasi F ( x ( t )). \u200b Persamaan diferensial biasa dibedakan dengan persamaan diferensial parsial yang melibatkan turunan parsial dari beberapa variabel. Persamaan diferensial biasa muncul dalam berbagai keadaan, termasuk geometri , mekanika , astronomi dan pemodelan populasi. Banyak matematikawan ternama telah mempelajari persamaan diferensial dan memberi sumbangan terhadap bidang studi ini termasuk Isaac Newton , Gottfried Leibniz , keluarga Bernoulli, Riccati , Clairaut , d'Alembert dan Euler . \u200b Terdapat beberapa metode numerik yang sering digunakan untuk menghitung solusi persamaan diferensial biasa yaitu : Metode Euler : \u200b Diberikan persamaan diferensial biasa y' = dy/dx = f(x, y); y(x0) = y0 misalkan yr = y(xr) adalah hampiran nilai y di xr yang dihitung dengan metode Euler. Dalam hal ini xr = x0 + rh, r = 0,1,2,... n, metoda Euler diturunkan dengan cara menguraikan y(xr+1) di sekitar xr ke dalam deret Taylor : \u200b Bila persamaan (1) dipotong sampai suku orde tiga, diperoleh : \u200b Berdasarkan bentuk baku : \u200b Maka persamaan (2) dapat ditulis menjadi : \u200b Dua suku pertama persamaan (3), yaitu : \u200b Dimana itu menyatakan metode Euler. Untuk menyederhanakan penulisan, persamaan metode Euler dapat juga ditulis lebih singkat sebagai : Metode Taylor \u200b Metode deret Taylor adalah metode yang umum untuk menurunkan rumus-rumus solusi persamaan diferensial biasa. Metode Euler merupakan metode deret Taylor yang paling sederhana. DIberikan persamaan diferensial biasa y'(x) = f(x,y) dengan kondisi awal y(x0) = y0 misalkan yr+1 = y(xr+1), r = 0,1,\u2026,n adalah hampiran nilai y di xr+1. Hampiran ini diperoleh dengan menguraikan yr+1 disekitar xr sebagai berikut : \u200b Persamaan di atas menyiratkan bahwa untuk menghitung hampiran nilai yr+1 , kita perlu menghitung y'(xr), y\"(xr) ,\u2026,y(n)(xr). Metode Heun (Perbaikan Metoda Euler) \u200b Metode Euler mempunyai ketelitian yang rendah karena galatnya besar (sebanding dengan h). Buruknya galat ini dapat dikurangi dengan menggunakan metode Heun, yang merupakan perbaikan metode Euler (modified Euler's method). Pada metode Heun, solusi dari metode Euler dijadikan sebagai solusi perkiraan awal (predictor). Selanjutnya, solusi perkiraan awal ini diperbaiki dengan metode Heun (corrector). \u200b Persamaan Heun: yr+1 = yr + h/2 [f(xr, yr) + f(xr+1, yr+1)] . Dalam persaman di atas, suku ruas kanan mengandung yr+1 . Nilai yr+1 ini adalah solusi perkiraan awal (predictor) yang dihitung dengan metode Euler. Karena itu, persamaan Heun dapat ditulis sebagai Predictor : y(0)r+1 = yr + hf(xr, yr) Corrector : yr+1 = yr + h/2 [f(xr, yr) + f(xr+1, y(0)r+1)] atau ditulis dalam satu kesatuan, yr+1 = yr + h/2[f(xr,yr) + f(xr+1, yr + hf(xr, yr)] Metode Runge-Kutta \u200b Penyelesaian persamaan diferensial biasa dengan metode deret Taylor ialah tidak praktis karena metode tersebut membutuhkan perhitungan turunan. Metode Runge-Kutta adalah alternatif lain dari metode deretTaylor yang tidak membutuhkan perhitungan turunan. Metode ini berusaha mendapatkan derajat ketelitian yang lebih tinggi dan sekaligus menghindarkan keperluan mencari turunan yang lebih tinggi. Metode Runge-Kutta adalah metode persamaan diferensial biasa yang paling populer karena banyak dipakai dalam praktek. Bentuk umum metoda Range-Kutta orde-n ialah: yr+1 = yr + a1k1 + a2k2 + ... + an kn dengan a1, a2, ..., an adalah tetapan, dan Listing Program print(\"f(x,y)=1+x^2\") print(\"yi+1 = y1 + hf(xi+yi)\") x1 = float(input(\"Masukkan x1= \")) x2 = float(input(\"Masukkan x2= \")) h = 1.01-x1 #Langsung saya atur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n=4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = -4 hasil = xi y=0 for i in range(n): print(\"hasil dari y\"+str(i)+\"= \"+ str(hasil)) hasil = xi + h*(1+(x1+y)**2) y+=h xi=hasil h = 0.01.","title":"Persamaan Diferensial Biasa"},{"location":"Tugas 6_Persamaan Diferensial Biasa/#persamaan-diferensial-biasa","text":"\u200b Persamaan diferensial biasa adalah persamaan diferensial dimana fungsi yang tidak diketahui (variabel terikat) adalah fungsi dari variabel bebas tunggal. Dalam bentuk paling sederhana fungsi yang tidak diketahui ini adalah fungsi riil atau fungsi kompleks, tetapi secara umum bisa juga berupa fungsi vektor maupun matriks. Lebih jauh lagi, persamaan diferensial biasa digolongkan berdasarkan orde tertinggi dari turunan terhadap variabel terikat yang muncul dalam persamaan tersebut. Contoh sederhana adalah hukum gerak kedua Newton yang menghasilkan persamaan diferensial \u200b untuk gerakan partikel dengan massa konstan m . Pada umumnya, gaya F tergantung kepada posisi partikel x(t) pada waktu t dan demikian fungsi yang tidak diketahui x(t) muncul pada kedua ruas persamaan diferensial seperti yang diindikasikan dalam notasi F ( x ( t )). \u200b Persamaan diferensial biasa dibedakan dengan persamaan diferensial parsial yang melibatkan turunan parsial dari beberapa variabel. Persamaan diferensial biasa muncul dalam berbagai keadaan, termasuk geometri , mekanika , astronomi dan pemodelan populasi. Banyak matematikawan ternama telah mempelajari persamaan diferensial dan memberi sumbangan terhadap bidang studi ini termasuk Isaac Newton , Gottfried Leibniz , keluarga Bernoulli, Riccati , Clairaut , d'Alembert dan Euler . \u200b Terdapat beberapa metode numerik yang sering digunakan untuk menghitung solusi persamaan diferensial biasa yaitu : Metode Euler : \u200b Diberikan persamaan diferensial biasa y' = dy/dx = f(x, y); y(x0) = y0 misalkan yr = y(xr) adalah hampiran nilai y di xr yang dihitung dengan metode Euler. Dalam hal ini xr = x0 + rh, r = 0,1,2,... n, metoda Euler diturunkan dengan cara menguraikan y(xr+1) di sekitar xr ke dalam deret Taylor : \u200b Bila persamaan (1) dipotong sampai suku orde tiga, diperoleh : \u200b Berdasarkan bentuk baku : \u200b Maka persamaan (2) dapat ditulis menjadi : \u200b Dua suku pertama persamaan (3), yaitu : \u200b Dimana itu menyatakan metode Euler. Untuk menyederhanakan penulisan, persamaan metode Euler dapat juga ditulis lebih singkat sebagai : Metode Taylor \u200b Metode deret Taylor adalah metode yang umum untuk menurunkan rumus-rumus solusi persamaan diferensial biasa. Metode Euler merupakan metode deret Taylor yang paling sederhana. DIberikan persamaan diferensial biasa y'(x) = f(x,y) dengan kondisi awal y(x0) = y0 misalkan yr+1 = y(xr+1), r = 0,1,\u2026,n adalah hampiran nilai y di xr+1. Hampiran ini diperoleh dengan menguraikan yr+1 disekitar xr sebagai berikut : \u200b Persamaan di atas menyiratkan bahwa untuk menghitung hampiran nilai yr+1 , kita perlu menghitung y'(xr), y\"(xr) ,\u2026,y(n)(xr). Metode Heun (Perbaikan Metoda Euler) \u200b Metode Euler mempunyai ketelitian yang rendah karena galatnya besar (sebanding dengan h). Buruknya galat ini dapat dikurangi dengan menggunakan metode Heun, yang merupakan perbaikan metode Euler (modified Euler's method). Pada metode Heun, solusi dari metode Euler dijadikan sebagai solusi perkiraan awal (predictor). Selanjutnya, solusi perkiraan awal ini diperbaiki dengan metode Heun (corrector). \u200b Persamaan Heun: yr+1 = yr + h/2 [f(xr, yr) + f(xr+1, yr+1)] . Dalam persaman di atas, suku ruas kanan mengandung yr+1 . Nilai yr+1 ini adalah solusi perkiraan awal (predictor) yang dihitung dengan metode Euler. Karena itu, persamaan Heun dapat ditulis sebagai Predictor : y(0)r+1 = yr + hf(xr, yr) Corrector : yr+1 = yr + h/2 [f(xr, yr) + f(xr+1, y(0)r+1)] atau ditulis dalam satu kesatuan, yr+1 = yr + h/2[f(xr,yr) + f(xr+1, yr + hf(xr, yr)] Metode Runge-Kutta \u200b Penyelesaian persamaan diferensial biasa dengan metode deret Taylor ialah tidak praktis karena metode tersebut membutuhkan perhitungan turunan. Metode Runge-Kutta adalah alternatif lain dari metode deretTaylor yang tidak membutuhkan perhitungan turunan. Metode ini berusaha mendapatkan derajat ketelitian yang lebih tinggi dan sekaligus menghindarkan keperluan mencari turunan yang lebih tinggi. Metode Runge-Kutta adalah metode persamaan diferensial biasa yang paling populer karena banyak dipakai dalam praktek. Bentuk umum metoda Range-Kutta orde-n ialah: yr+1 = yr + a1k1 + a2k2 + ... + an kn dengan a1, a2, ..., an adalah tetapan, dan Listing Program print(\"f(x,y)=1+x^2\") print(\"yi+1 = y1 + hf(xi+yi)\") x1 = float(input(\"Masukkan x1= \")) x2 = float(input(\"Masukkan x2= \")) h = 1.01-x1 #Langsung saya atur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n=4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = -4 hasil = xi y=0 for i in range(n): print(\"hasil dari y\"+str(i)+\"= \"+ str(hasil)) hasil = xi + h*(1+(x1+y)**2) y+=h xi=hasil h = 0.01.","title":"Persamaan Diferensial Biasa"},{"location":"Tugas 7_Metode dan Simulasi Monte Carlo/","text":"Metode dan Simulasi Monte Carlo \u200b Metode Monte Carlo adalah algoritma komputasi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit, terutama integral multidimensi dengan syarat dan batasan yang rumit. Metode Monte Carlo sangat penting dalam fisika komputasi dan bidang terapan lainnya, dan memiliki aplikasi yang beragam mulai dari perhitungan kromodinamika kuantum esoterik hingga perancangan aerodinamika. Metode ini terbukti efisien dalam memecahkan persamaan diferensial integral medan radians, sehingga metode ini digunakan dalam perhitungan iluminasi global yang menghasilkan gambar-gambar fotorealistik model tiga dimensi, dimana diterapkan dalam video games, arsitektur, perancangan, film yang dihasilkan oleh komputer, efek-efek khusus dalam film, bisnis, ekonomi, dan bidang lainnya. \u200b Karena algoritme ini memerlukan pengulangan (repetisi) dan perhitungan yang amat kompleks, metode Monte Carlo pada umumnya dilakukan menggunakan komputer, dan memakai berbagai teknik simulasi komputer. Algoritma Monte Carlo adalah metode Monte Carlo numerik yang digunakan untuk menemukan solusi problem matematis (yang dapat terdiri dari banyak variabel) yang susah dipecahkan, misalnya dengan kalkulus integral, atau metode numerik lainnya. \u200b Simulasi monte carlo adalah sebuah simulasi untuk menentukan suatu angka random dari data sampel dengan berdistribusi tertentu. Tujuan simulasi Monte carlo adalah menemukan nilai yang mendekati nilai sesungguhnya, atau nilai yang akan terjadi berdasarkan distribusi dari data sampling. Oleh sebab kemampuannya mampu memprediksi suatu nilai, maka Monte Carlo dahulu sering digunakan untuk kepentingan judi di kasino. \u200b Dalam dunia keuangan dan perbankan, simulasi Monte carlo tentu sangat dibutuhkan untuk menghitung resiko finansial. Bagi perbankan yang salah satu kegiatan utamanya adalah memberikan kredit kepada nasabah, tentu Monte carlo dibutuhkan untuk memprediksi resiko finansial perbankan akibat kredit macet. Dalam duni investasi, investor dapat memanfaatkan simulasi Monte Carlo untuk mengetahui resiko gagal bayar dari suatu instrumen investasi. Pada dasarnya, dalam dunia keuangan dan perbankan Metode simulasi Monte carlo dapat membantu kita dalam melakukan mitigasi atas resiko. \u200b Prosedur Monte Carlo : tentukan angka sampling yang akan disimulasikan. temukan distribusi dari data sampling yang ada simulasi berdasarkan distribusi di atas Listing Program 1 dan output from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 #function for integral def func(x): return (4-x**2)**0.5 area = [] for i in range(N): xrand = np.zeros(N) for i in range(len(xrand)): xrand[i] = random.uniform(a,b) integral = 0.0 for i in range(N): integral+=func(xrand[i]) jawab = (b-a)/float(N)*integral area.append(jawab) plt.title(\"Nilai phi\") plt.hist(area,bins = 30, ec = 'black') plt.xlabel(\"Area\") plt.show() print(\"Nilai phi terletak pada x =\",jawab) Nilai phi terletak pada x = 3.131335254731468 Listing Program 2 dan output from scipy import random #import library random dari scipy import numpy as np #import library numpy a = -1 b = 1 N=100 n=3 xrand=np.zeros(N)#dx yrand=np.zeros(N)#dy zrand=np.zeros(N)#dz #fungsi np.zeros mengembalikan array baru dengan bentuk dari tipe yang diberikan, di mana nilai elemen sebagai 0. integral=0.0 for i in range(n+1): for i in range(len(xrand)): xrand[i]=random.uniform(a,b) for i in range(len(yrand)): yrand[i]=random.uniform(a,b) for i in range(len(zrand)): zrand[i]=random.uniform(a,b) def func(x,y,z): return (x**2)+(y**2)+(z**2) for i in range(N): integral+=func(xrand[i],yrand[i],zrand[i]) jwb=(b-a)/float(N)*integral print(\"Hasil perkiraan : \",jwb) Hasil perkiraan : 8.196431252268816","title":"Metode dan Simulasi Monte Carlo"},{"location":"Tugas 7_Metode dan Simulasi Monte Carlo/#metode-dan-simulasi-monte-carlo","text":"\u200b Metode Monte Carlo adalah algoritma komputasi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit, terutama integral multidimensi dengan syarat dan batasan yang rumit. Metode Monte Carlo sangat penting dalam fisika komputasi dan bidang terapan lainnya, dan memiliki aplikasi yang beragam mulai dari perhitungan kromodinamika kuantum esoterik hingga perancangan aerodinamika. Metode ini terbukti efisien dalam memecahkan persamaan diferensial integral medan radians, sehingga metode ini digunakan dalam perhitungan iluminasi global yang menghasilkan gambar-gambar fotorealistik model tiga dimensi, dimana diterapkan dalam video games, arsitektur, perancangan, film yang dihasilkan oleh komputer, efek-efek khusus dalam film, bisnis, ekonomi, dan bidang lainnya. \u200b Karena algoritme ini memerlukan pengulangan (repetisi) dan perhitungan yang amat kompleks, metode Monte Carlo pada umumnya dilakukan menggunakan komputer, dan memakai berbagai teknik simulasi komputer. Algoritma Monte Carlo adalah metode Monte Carlo numerik yang digunakan untuk menemukan solusi problem matematis (yang dapat terdiri dari banyak variabel) yang susah dipecahkan, misalnya dengan kalkulus integral, atau metode numerik lainnya. \u200b Simulasi monte carlo adalah sebuah simulasi untuk menentukan suatu angka random dari data sampel dengan berdistribusi tertentu. Tujuan simulasi Monte carlo adalah menemukan nilai yang mendekati nilai sesungguhnya, atau nilai yang akan terjadi berdasarkan distribusi dari data sampling. Oleh sebab kemampuannya mampu memprediksi suatu nilai, maka Monte Carlo dahulu sering digunakan untuk kepentingan judi di kasino. \u200b Dalam dunia keuangan dan perbankan, simulasi Monte carlo tentu sangat dibutuhkan untuk menghitung resiko finansial. Bagi perbankan yang salah satu kegiatan utamanya adalah memberikan kredit kepada nasabah, tentu Monte carlo dibutuhkan untuk memprediksi resiko finansial perbankan akibat kredit macet. Dalam duni investasi, investor dapat memanfaatkan simulasi Monte Carlo untuk mengetahui resiko gagal bayar dari suatu instrumen investasi. Pada dasarnya, dalam dunia keuangan dan perbankan Metode simulasi Monte carlo dapat membantu kita dalam melakukan mitigasi atas resiko. \u200b Prosedur Monte Carlo : tentukan angka sampling yang akan disimulasikan. temukan distribusi dari data sampling yang ada simulasi berdasarkan distribusi di atas Listing Program 1 dan output from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 #function for integral def func(x): return (4-x**2)**0.5 area = [] for i in range(N): xrand = np.zeros(N) for i in range(len(xrand)): xrand[i] = random.uniform(a,b) integral = 0.0 for i in range(N): integral+=func(xrand[i]) jawab = (b-a)/float(N)*integral area.append(jawab) plt.title(\"Nilai phi\") plt.hist(area,bins = 30, ec = 'black') plt.xlabel(\"Area\") plt.show() print(\"Nilai phi terletak pada x =\",jawab) Nilai phi terletak pada x = 3.131335254731468 Listing Program 2 dan output from scipy import random #import library random dari scipy import numpy as np #import library numpy a = -1 b = 1 N=100 n=3 xrand=np.zeros(N)#dx yrand=np.zeros(N)#dy zrand=np.zeros(N)#dz #fungsi np.zeros mengembalikan array baru dengan bentuk dari tipe yang diberikan, di mana nilai elemen sebagai 0. integral=0.0 for i in range(n+1): for i in range(len(xrand)): xrand[i]=random.uniform(a,b) for i in range(len(yrand)): yrand[i]=random.uniform(a,b) for i in range(len(zrand)): zrand[i]=random.uniform(a,b) def func(x,y,z): return (x**2)+(y**2)+(z**2) for i in range(N): integral+=func(xrand[i],yrand[i],zrand[i]) jwb=(b-a)/float(N)*integral print(\"Hasil perkiraan : \",jwb) Hasil perkiraan : 8.196431252268816","title":"Metode dan Simulasi Monte Carlo"}]}